<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text to Zlib Hex Compressor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            min-height: 500px;
        }

        .input-section, .output-section {
            padding: 30px;
        }

        .input-section {
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
        }

        .output-section {
            background: #ffffff;
        }

        .section-title {
            font-size: 1.3rem;
            margin-bottom: 20px;
            color: #333;
            font-weight: 600;
        }

        .input-section .section-title {
            color: #4facfe;
        }

        .output-section .section-title {
            color: #28a745;
        }

        textarea {
            width: 100%;
            height: 300px;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-family: monospace;
            font-size: 18px;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        textarea:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }

        .hex-output {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 16px;
            line-height: 1.4;
            height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .stats {
            margin-top: 20px;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
        }

        .stats h4 {
            color: #1976d2;
            margin-bottom: 10px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .stat-value {
            font-weight: 600;
            color: #333;
        }

        .compression-ratio {
            color: #4caf50;
        }

        .compression-ratio.negative {
            color: #dc3545;
        }

        .deflate-breakdown {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #ff9800;
        }

        .deflate-breakdown h4 {
            color: #e65100;
            margin-bottom: 15px;
        }

        .block-navigation {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .block-slider {
            flex: 1;
            height: 6px;
            background: #ddd;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .block-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #ff9800;
            border-radius: 50%;
            cursor: pointer;
        }

        .block-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #ff9800;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .block-details {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 15px;
        }

        .block-info {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .block-info > div {
            font-size: 14px;
            color: #333;
        }

        .block-visualization {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre;
        }

        .highlighted-text {
            margin-top: 20px;
            padding: 15px;
            background: #e8f5e8;
            border-radius: 8px;
            border-left: 4px solid #4caf50;
        }

        .highlighted-text h4 {
            color: #2e7d32;
            margin-bottom: 15px;
        }

        .text-display {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .text-highlight {
            background: #ffeb3b;
            padding: 2px 4px;
            border-radius: 2px;
            font-weight: bold;
        }

        .hex-highlight {
            background: #2196f3;
            color: #fff;
            font-weight: bold;
        }

        .hex-dim {
            color: #666;
        }

        .no-data {
            color: #666;
            font-style: italic;
            text-align: center;
            padding: 50px 20px;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .input-section {
                border-right: none;
                border-bottom: 1px solid #e9ecef;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <div class="input-section">
                <h2 class="section-title">Input Text</h2>
                <textarea id="inputText" placeholder="Enter your text here..."></textarea>
            </div>
            
                <div class="output-section">
                <h2 class="section-title">Zlib Hex Output (Level 9)</h2>
                
                <div id="stats" class="stats" style="display: none;">
                    <h4>Compression Statistics</h4>
                    <div class="stat-item">
                        <span>Original size:</span>
                        <span class="stat-value" id="originalSize">0 bytes</span>
                        <span>Compressed size:</span>
                        <span class="stat-value" id="compressedSize">0 bytes</span>
                        <span>Compression ratio:</span>
                        <span class="stat-value compression-ratio" id="compressionRatio">0%</span>
                    </div>
                </div>
                
                <div id="hexOutput" class="hex-output">
                    <div class="no-data">Enter some text to see the compressed zlib stream as hex...</div>
                </div>

                <div id="deflateBreakdown" class="deflate-breakdown" style="display: none;">
                    <h4>DEFLATE Stream Breakdown</h4>
                    <div class="block-navigation">
                        <label for="blockSlider">Block:</label>
                        <input type="range" id="blockSlider" min="0" max="0" value="0" class="block-slider">
                        <span id="blockInfo">Block 0 of 0</span>
                    </div>
                    <div id="blockDetails" class="block-details">
                        <div class="block-info">
                            <div class="block-type">Type: <span id="blockType">-</span></div>
                            <div class="block-size">Size: <span id="blockSize">-</span></div>
                            <div class="block-position">Position: <span id="blockPosition">-</span></div>
                        </div>
                        <div class="block-visualization" id="blockVisualization"></div>
                    </div>
                </div>

                <div id="highlightedText" class="highlighted-text" style="display: none;">
                    <h4>Corresponding Input Text</h4>
                    <div id="textDisplay" class="text-display"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="./fflate.js"></script>

    <!-- fflate CDN -->
    <script>


        const inputText = document.getElementById('inputText');
        const hexOutput = document.getElementById('hexOutput');
        const stats = document.getElementById('stats');
        const originalSize = document.getElementById('originalSize');
        const compressedSize = document.getElementById('compressedSize');
        const compressionRatio = document.getElementById('compressionRatio');
        const deflateBreakdown = document.getElementById('deflateBreakdown');
        const blockSlider = document.getElementById('blockSlider');
        const blockInfo = document.getElementById('blockInfo');
        const blockType = document.getElementById('blockType');
        const blockSize = document.getElementById('blockSize');
        const blockPosition = document.getElementById('blockPosition');
        const blockVisualization = document.getElementById('blockVisualization');
        const highlightedText = document.getElementById('highlightedText');
        const textDisplay = document.getElementById('textDisplay');

        let deflateBlocks = [];
        let deflateItems = [];
        let currentText = '';

        // Bit array utility for easier DEFLATE parsing
        class BitReader {
            constructor(data) {
                this.data = new Uint8Array(data);
                this.byteIndex = 0;
                this.bitIndex = 0;
            }

            readBits(count) {
                let result = 0;
                for (let i = 0; i < count; i++) {
                    if (this.byteIndex >= this.data.length) {
                        throw new Error('Unexpected end of data');
                    }
                    
                    const bit = (this.data[this.byteIndex] >> this.bitIndex) & 1;
                    result |= bit << i;
                    
                    this.bitIndex++;
                    if (this.bitIndex === 8) {
                        this.bitIndex = 0;
                        this.byteIndex++;
                    }
                }
                return result;
            }

            readByte() {
                if (this.bitIndex !== 0) {
                    this.bitIndex = 0;
                    this.byteIndex++;
                }
                if (this.byteIndex >= this.data.length) {
                    throw new Error('Unexpected end of data');
                }
                return this.data[this.byteIndex++];
            }

            readBytes(count) {
                if (this.bitIndex !== 0) {
                    this.bitIndex = 0;
                    this.byteIndex++;
                }
                const result = this.data.slice(this.byteIndex, this.byteIndex + count);
                this.byteIndex += count;
                return result;
            }

            alignToByte() {
                if (this.bitIndex !== 0) {
                    this.bitIndex = 0;
                    this.byteIndex++;
                }
            }

            getPosition() {
                return { byte: this.byteIndex, bit: this.bitIndex };
            }
        }

        // DEFLATE parser following RFC 1951
        function parseDeflateBlocks(zlibData) {
            const blocks = [];
            const data = new Uint8Array(zlibData);
            
            console.log('Parsing DEFLATE blocks. Zlib data length:', zlibData.length);
            console.log('Zlib data:', Array.from(data).map(b => b.toString(16).padStart(2, '0')).join(' '));
            
            // Skip zlib header (2 bytes) and checksum (4 bytes at end)
            const deflateData = data.slice(2, data.length - 4);
            console.log('DEFLATE data length:', deflateData.length);
            console.log('DEFLATE data:', Array.from(deflateData).map(b => b.toString(16).padStart(2, '0')).join(' '));
            
            const reader = new BitReader(deflateData);
            let blockIndex = 0;
            
            try {
                while (true) {
                    const blockStart = reader.getPosition();
                    console.log(`Parsing block ${blockIndex} at position:`, blockStart);
                    
                    // Read block header (3 bits)
                    const bfinal = reader.readBits(1);
                    const btype = reader.readBits(2);
                    
                    console.log(`Block ${blockIndex}: BFINAL=${bfinal}, BTYPE=${btype}`);
                    
                    let blockType = '';
                    let blockSize = 0;
                    let content = '';
                    let decompressedData = '';
                    let items = [];
                    
                    if (btype === 0) {
                        // Uncompressed block (BTYPE=00)
                        blockType = 'Uncompressed';
                        reader.alignToByte(); // Skip to byte boundary
                        
                        const len = reader.readByte() | (reader.readByte() << 8);
                        const nlen = reader.readByte() | (reader.readByte() << 8);
                        
                        if ((len ^ nlen) === 0xFFFF) {
                            const dataStartPos = reader.getPosition();
                            const data = reader.readBytes(len);
                            blockSize = 4 + len; // 4 bytes for len/nlen + data
                            content = `Length: ${len} bytes\nData: ${Array.from(data).map(b => b.toString(16).padStart(2, '0')).join(' ')}`;
                            decompressedData = new TextDecoder().decode(data);
                            
                            // Create items for uncompressed block
                            for (let i = 0; i < data.length; i++) {
                                const char = String.fromCharCode(data[i]);
                                const bitStart = dataStartPos.byte * 8 + dataStartPos.bit + (i * 8);
                                const bitEnd = bitStart + 8; // Each byte is 8 bits
                                
                                items.push({
                                    type: 'literal',
                                    value: char,
                                    charCode: data[i],
                                    position: { byte: dataStartPos.byte + i, bit: 0 },
                                    bitStart: bitStart,
                                    bitEnd: bitEnd
                                });
                            }
                            content += `\n\nItems: ${items.length} literals`;
                        } else {
                            blockSize = 4;
                            content = 'Invalid uncompressed block (len != ~nlen)';
                        }
                    } else if (btype === 1) {
                        // Fixed Huffman block (BTYPE=01)
                        blockType = 'Fixed Huffman';
                        const result = parseFixedHuffmanBlock(reader);
                        blockSize = result.size;
                        content = result.content;
                        decompressedData = result.decompressedData;
                        items = result.items || [];
                    } else if (btype === 2) {
                        // Dynamic Huffman block (BTYPE=10)
                        blockType = 'Dynamic Huffman';
                        const result = parseDynamicHuffmanBlock(reader);
                        blockSize = result.size;
                        content = result.content;
                        decompressedData = result.decompressedData;
                        items = result.items || [];
                    } else {
                        // Reserved (BTYPE=11)
                        blockType = 'Reserved (Error)';
                        blockSize = 0;
                        content = 'Invalid block type (reserved)';
                    }
                    
                    const blockEnd = reader.getPosition();
                    
                    blocks.push({
                        index: blockIndex,
                        type: blockType,
                        size: blockSize,
                        start: blockStart,
                        end: blockEnd,
                        content: content,
                        decompressedData: decompressedData,
                        items: items,
                        isFinal: bfinal === 1
                    });
                    
                    blockIndex++;
                    
                    if (bfinal === 1) break;
                }
            } catch (error) {
                console.error('Error parsing DEFLATE blocks:', error);
                // Add error block if parsing fails
                blocks.push({
                    index: blockIndex,
                    type: 'Parse Error',
                    size: 0,
                    start: reader.getPosition(),
                    end: reader.getPosition(),
                    content: `Error: ${error.message}`,
                    decompressedData: '',
                    isFinal: true
                });
            }
            
            console.log('Parsing complete. Total blocks:', blocks.length);
            console.log('Final blocks:', blocks);
            return blocks;
        }

        // Parse fixed Huffman block (BTYPE=01)
        function parseFixedHuffmanBlock(reader) {
            const startPos = reader.getPosition();
            let content = 'Fixed Huffman codes:\n';
            content += 'Literal/Length codes: 0-143 (8 bits), 144-255 (9 bits), 256-279 (7 bits), 280-287 (8 bits)\n';
            content += 'Distance codes: 0-31 (5 bits)\n\n';
            
            let decompressedData = '';
            let literalCount = 0;
            let lengthCount = 0;
            let distanceCount = 0;
            const items = [];
            
            // Build the fixed Huffman code table according to RFC 1951
            const fixedLiteralLengthCodes = buildFixedLiteralLengthCodes();
            const fixedDistanceCodes = buildFixedDistanceCodes();
            
            try {
                while (reader.byteIndex < reader.data.length) {
                    // Read literal/length code using fixed Huffman table
                    let code = 0;
                    let bits = 0;
                    let found = false;
                    
                    // Read bits one by one until we find a valid code
                    // Huffman codes are packed with MSB first, so we need to reverse the bit order
                    while (bits < 9 && reader.byteIndex < reader.data.length && !found) {
                        const bit = reader.readBits(1);
                        code = (code << 1) | bit; // Build code with MSB first
                        bits++;
                        
                        // Check against fixed code table
                        if (fixedLiteralLengthCodes[code] && fixedLiteralLengthCodes[code].length === bits) {
                            code = fixedLiteralLengthCodes[code].symbol;
                            found = true;
                        }
                    }
                    
                    if (!found) {
                        content += `Parse error: Could not decode code at position ${reader.getPosition().byte}.${reader.getPosition().bit}\n`;
                        break;
                    }
                    
                    if (code < 256) {
                        // Literal byte
                        const char = String.fromCharCode(code);
                        decompressedData += char;
                        literalCount++;
                        content += `Literal: ${code} ('${char}')\n`;
                        
                        // Calculate bit positions for this literal
                        const currentPos = reader.getPosition();
                        const bitStart = currentPos.byte * 8 + currentPos.bit - bits;
                        const bitEnd = currentPos.byte * 8 + currentPos.bit;
                        
                        items.push({
                            type: 'literal',
                            value: char,
                            charCode: code,
                            position: currentPos,
                            bitStart: bitStart,
                            bitEnd: bitEnd
                        });
                    } else if (code === 256) {
                        // End of block
                        content += 'End of block\n';
                        break;
                    } else if (code >= 257 && code <= 285) {
                        // Length code
                        const lengthStartPos = reader.getPosition();
                        const lengthBitStart = lengthStartPos.byte * 8 + lengthStartPos.bit - bits;
                        
                        const length = getLengthFromCode(code, reader);
                        const distanceResult = readDistanceCodeFixed(reader, fixedDistanceCodes);
                        const distance = getDistanceFromCode(distanceResult.symbol, reader);
                        
                        const currentPos = reader.getPosition();
                        const bitEnd = currentPos.byte * 8 + currentPos.bit;
                        
                        // Generate the repeated text for LZ77 reference
                        const repeatedText = generateLZ77Text(length, distance, decompressedData);
                        decompressedData += repeatedText;
                        lengthCount++;
                        distanceCount++;
                        content += `LZ77: length=${length}, distance=${distance} -> "${repeatedText}"\n`;
                        
                        items.push({
                            type: 'lz77',
                            length: length,
                            distance: distance,
                            text: repeatedText,
                            position: currentPos,
                            bitStart: lengthBitStart,
                            bitEnd: distanceResult.bitEnd
                        });
                    }
                }
            } catch (error) {
                content += `Parse error: ${error.message}\n`;
            }
            
            const endPos = reader.getPosition();
            content += `\nSummary: ${literalCount} literals, ${lengthCount} length codes, ${distanceCount} distance codes`;
            
            return {
                size: endPos.byte - startPos.byte,
                content: content,
                decompressedData: decompressedData,
                items: items
            };
        }

        // Generate the actual repeated text for LZ77 references
        function generateLZ77Text(length, distance, currentData) {
            let result = '';
            const startPos = currentData.length - distance;
            
            for (let i = 0; i < length; i++) {
                if (startPos + i >= 0 && startPos + i < currentData.length) {
                    result += currentData[startPos + i];
                }
            }
            
            return result;
        }

        // Build fixed literal/length codes according to RFC 1951
        function buildFixedLiteralLengthCodes() {
            const codes = {};
            
            // 0-143: 8 bits, codes 00110000 through 10111111
            for (let i = 0; i <= 143; i++) {
                const code = 0x30 + i; // 00110000 + i
                codes[code] = { symbol: i, length: 8 };
            }
            
            // 144-255: 9 bits, codes 110010000 through 111111111
            for (let i = 144; i <= 255; i++) {
                const code = 0x190 + (i - 144); // 110010000 + (i - 144)
                codes[code] = { symbol: i, length: 9 };
            }
            
            // 256-279: 7 bits, codes 0000000 through 0010111
            for (let i = 256; i <= 279; i++) {
                const code = i - 256; // 0 through 23
                codes[code] = { symbol: i, length: 7 };
            }
            
            // 280-287: 8 bits, codes 11000000 through 11000111
            for (let i = 280; i <= 287; i++) {
                const code = 0xC0 + (i - 280); // 11000000 + (i - 280)
                codes[code] = { symbol: i, length: 8 };
            }
            
            return codes;
        }

        // Build fixed distance codes according to RFC 1951
        function buildFixedDistanceCodes() {
            const codes = {};
            
            // 0-31: 5 bits, codes 00000 through 11111
            for (let i = 0; i <= 31; i++) {
                codes[i] = { symbol: i, length: 5 };
            }
            
            return codes;
        }

        // Read distance code using fixed codes
        function readDistanceCodeFixed(reader, fixedDistanceCodes) {
            let code = 0;
            let bits = 0;
            const startPos = reader.getPosition();
            
            while (bits < 5 && reader.byteIndex < reader.data.length) {
                const bit = reader.readBits(1);
                code = (code << 1) | bit; // Build code with MSB first
                bits++;
                
                if (fixedDistanceCodes[code] && fixedDistanceCodes[code].length === bits) {
                    return {
                        symbol: fixedDistanceCodes[code].symbol,
                        bitStart: startPos.byte * 8 + startPos.bit,
                        bitEnd: reader.getPosition().byte * 8 + reader.getPosition().bit
                    };
                }
            }
            
            throw new Error('Invalid distance code');
        }

        // Parse dynamic Huffman block (BTYPE=10)
        function parseDynamicHuffmanBlock(reader) {
            const startPos = reader.getPosition();
            let content = 'Dynamic Huffman codes:\n';
            let decompressedData = '';
            const items = [];
            
            try {
                // Read header
                const hlit = reader.readBits(5) + 257;  // 257-286
                const hdist = reader.readBits(5) + 1;   // 1-32
                const hclen = reader.readBits(4) + 4;   // 4-19
                
                content += `HLIT: ${hlit} (literal/length codes)\n`;
                content += `HDIST: ${hdist} (distance codes)\n`;
                content += `HCLEN: ${hclen} (code length codes)\n\n`;
                
                // Read code length codes
                const codeLengthOrder = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
                const codeLengths = new Array(19).fill(0);
                
                for (let i = 0; i < hclen; i++) {
                    codeLengths[codeLengthOrder[i]] = reader.readBits(3);
                }
                
                content += 'Code length codes: ' + codeLengths.slice(0, hclen).join(', ') + '\n';
                console.log('Code length codes:', codeLengths);
                console.log('HCLEN:', hclen);
                
                // Build Huffman tree for code lengths
                const codeLengthTree = buildHuffmanTree(codeLengths, 18);
                content += `\nCode length tree built\n`;
                
                // Decode literal/length and distance code lengths
                const allCodeLengths = [];
                let totalCodes = hlit + hdist;
                
                console.log('Decoding code length codes...');
                console.log('  Total codes needed:', totalCodes);
                console.log('  Available bits before decoding:', (reader.data.length - reader.byteIndex) * 8 - reader.bitIndex);
                
                let attempts = 0;
                while (allCodeLengths.length < totalCodes && attempts < 1000) {
                    attempts++;
                    try {
                        console.log(`  Decoding code ${allCodeLengths.length + 1}/${totalCodes}, available bits: ${(reader.data.length - reader.byteIndex) * 8 - reader.bitIndex}`);
                        console.log(`  Reader position: ${reader.byteIndex}.${reader.bitIndex}`);
                        console.log(`  Code length tree entries:`, Object.keys(codeLengthTree).length);
                        const symbolResult = decodeSymbol(reader, codeLengthTree);
                        const symbol = symbolResult.symbol;
                        console.log(`    Decoded symbol: ${symbol}`);
                        
                        if (symbol < 16) {
                            // Direct code length
                            allCodeLengths.push(symbol);
                            console.log(`    Direct code length: ${symbol}, array length now: ${allCodeLengths.length}`);
                        } else if (symbol === 16) {
                            // Copy previous code length 3-6 times
                            const repeat = reader.readBits(2) + 3;
                            const lastLength = allCodeLengths[allCodeLengths.length - 1];
                            console.log(`    Copy ${lastLength} for ${repeat} times`);
                            for (let i = 0; i < repeat; i++) {
                                allCodeLengths.push(lastLength);
                            }
                        } else if (symbol === 17) {
                            // Repeat code length 0 for 3-10 times
                            const repeat = reader.readBits(3) + 3;
                            console.log(`    Repeat 0 for ${repeat} times`);
                            for (let i = 0; i < repeat; i++) {
                                allCodeLengths.push(0);
                            }
                        } else if (symbol === 18) {
                            // Repeat code length 0 for 11-138 times
                            const repeat = reader.readBits(7) + 11;
                            console.log(`    Repeat 0 for ${repeat} times`);
                            for (let i = 0; i < repeat; i++) {
                                allCodeLengths.push(0);
                            }
                        }
                    } catch (error) {
                        console.log(`Error decoding code length at position ${allCodeLengths.length}:`, error.message);
                        console.log(`  Available bits: ${(reader.data.length - reader.byteIndex) * 8 - reader.bitIndex}`);
                        console.log(`  Codes decoded so far: ${allCodeLengths.length}/${totalCodes}`);
                        throw error;
                    }
                }
                
                if (attempts >= 1000) {
                    console.log('Warning: Hit attempt limit, stopping code length decoding');
                }
                
                console.log(`Code length decoding complete: ${allCodeLengths.length}/${totalCodes} codes decoded`);
                
                // Split into literal/length and distance code lengths
                const literalLengths = allCodeLengths.slice(0, hlit);
                const distanceLengths = allCodeLengths.slice(hlit, hlit + hdist);
                
                console.log(`Literal/length code lengths: ${literalLengths.length} codes`);
                console.log(`Distance code lengths: ${distanceLengths.length} codes`);
                
                if (literalLengths.length === 0 || distanceLengths.length === 0) {
                    content += `ERROR: Failed to decode code lengths. Got ${allCodeLengths.length}/${totalCodes} codes.\n`;
                    content += `This suggests the compressed data is corrupted or the parser has a bug.\n`;
                    throw new Error(`Failed to decode code lengths: got ${allCodeLengths.length}/${totalCodes} codes`);
                }
                
                content += `Literal/length code lengths: ${literalLengths.slice(0, 20).join(', ')}${literalLengths.length > 20 ? '...' : ''}\n`;
                content += `Distance code lengths: ${distanceLengths.join(', ')}\n\n`;
                
                // Build Huffman trees
                const literalLengthTree = buildHuffmanTree(literalLengths, hlit - 1);
                const distanceTree = buildHuffmanTree(distanceLengths, hdist - 1);
                
                content += `Huffman trees built\n\n`;
                
                // Decode the actual compressed data
                let literalCount = 0;
                let lengthCount = 0;
                let distanceCount = 0;
                
                while (true) {
                    const symbolResult = decodeSymbol(reader, literalLengthTree);
                    const symbol = symbolResult.symbol;
                    
                    if (symbol < 256) {
                        // Literal byte
                        const char = String.fromCharCode(symbol);
                        decompressedData += char;
                        literalCount++;
                        content += `Literal: ${symbol} ('${char}')\n`;
                        
                        items.push({
                            type: 'literal',
                            value: char,
                            charCode: symbol,
                            position: reader.getPosition(),
                            bitStart: symbolResult.bitStart,
                            bitEnd: symbolResult.bitEnd
                        });
                    } else if (symbol === 256) {
                        // End of block
                        content += 'End of block\n';
                        break;
                    } else if (symbol >= 257 && symbol <= 285) {
                        // Length code
                        const length = getLengthFromCode(symbol, reader);
                        const distanceResult = decodeSymbol(reader, distanceTree);
                        const distance = getDistanceFromCode(distanceResult.symbol, reader);
                        
                        const currentPos = reader.getPosition();
                        
                        // Generate the repeated text for LZ77 reference
                        const repeatedText = generateLZ77Text(length, distance, decompressedData);
                        decompressedData += repeatedText;
                        lengthCount++;
                        distanceCount++;
                        content += `LZ77: length=${length}, distance=${distance} -> "${repeatedText}"\n`;
                        
                        items.push({
                            type: 'lz77',
                            length: length,
                            distance: distance,
                            text: repeatedText,
                            position: currentPos,
                            bitStart: symbolResult.bitStart,
                            bitEnd: distanceResult.bitEnd
                        });
                    }
                }
                
                content += `\nSummary: ${literalCount} literals, ${lengthCount} length codes, ${distanceCount} distance codes`;
                
            } catch (error) {
                content += `Parse error: ${error.message}\n`;
            }
            
            const endPos = reader.getPosition();
            
            return {
                size: endPos.byte - startPos.byte,
                content: content,
                decompressedData: decompressedData,
                items: items
            };
        }

        // Build Huffman tree from code lengths
        function buildHuffmanTree(codeLengths, maxSymbol) {
            console.log('Building Huffman tree:');
            console.log('  Code lengths:', codeLengths.slice(0, Math.min(20, codeLengths.length)));
            console.log('  Max symbol:', maxSymbol);
            
            if (codeLengths.length === 0) {
                console.log('  ERROR: Empty code lengths array');
                throw new Error('Cannot build Huffman tree from empty code lengths array');
            }
            
            // Count codes of each length
            const blCount = new Array(16).fill(0);
            for (let i = 0; i <= maxSymbol; i++) {
                if (codeLengths[i] > 0) {
                    blCount[codeLengths[i]]++;
                }
            }
            
            console.log('  Length counts:', blCount);
            
            // Find minimum code for each length
            const nextCode = new Array(16).fill(0);
            let code = 0;
            blCount[0] = 0;
            
            for (let bits = 1; bits <= 15; bits++) {
                code = (code + blCount[bits - 1]) << 1;
                nextCode[bits] = code;
            }
            
            console.log('  Next codes:', nextCode);
            
            // Assign codes
            const tree = {};
            for (let i = 0; i <= maxSymbol; i++) {
                const len = codeLengths[i];
                if (len !== 0) {
                    const codeValue = nextCode[len];
                    console.log(`  Assigning code ${codeValue} to symbol ${i} with length ${len}`);
                    if (isNaN(codeValue) || codeValue === undefined) {
                        console.log(`  ERROR: Invalid code value for length ${len}, nextCode[${len}] = ${nextCode[len]}`);
                    }
                    tree[codeValue] = { symbol: i, length: len };
                    nextCode[len]++;
                }
            }
            
            console.log('  Tree entries:', Object.keys(tree).length);
            console.log('  Sample tree entries:', Object.entries(tree).slice(0, 10));
            
            return tree;
        }

        // Decode a symbol using a Huffman tree
        function decodeSymbol(reader, tree) {
            let code = 0;
            let bits = 0;
            const startPos = reader.getPosition();
            const debugBits = [];
            
            console.log(`    decodeSymbol: Starting at position ${startPos.byte}.${startPos.bit}`);
            console.log(`    decodeSymbol: Tree has ${Object.keys(tree).length} entries:`, Object.keys(tree));
            
            // Read bits until we find a valid code
            while (bits < 15) { // Maximum code length is 15
                const bit = reader.readBits(1);
                code = (code << 1) | bit; // Build code MSB-first
                bits++;
                debugBits.push(bit);
                
                console.log(`    decodeSymbol: Read bit ${bit}, code now ${code.toString(2).padStart(bits, '0')}, bits=${bits}`);
                
                if (tree[code] && tree[code].length === bits) {
                    console.log(`    decodeSymbol: Found match! Symbol ${tree[code].symbol}`);
                    return {
                        symbol: tree[code].symbol,
                        bitStart: startPos.byte * 8 + startPos.bit,
                        bitEnd: reader.getPosition().byte * 8 + reader.getPosition().bit
                    };
                }
            }
            
            // Debug information for failed decode
            const currentPos = reader.getPosition();
            console.log('Failed to decode Huffman code:');
            console.log('  Bits read:', debugBits.join(''));
            console.log('  Code value:', code.toString(2).padStart(bits, '0'));
            console.log('  Position:', `${currentPos.byte}.${currentPos.bit}`);
            console.log('  Available tree entries:', Object.keys(tree).filter(k => tree[k].length <= bits));
            
            throw new Error(`Invalid Huffman code: ${debugBits.join('')} (${code}) at position ${currentPos.byte}.${currentPos.bit}`);
        }

        // Helper functions for LZ77 decoding
        function getLengthFromCode(code, reader) {
            const lengthTable = [
                [257, 0, 3], [258, 0, 4], [259, 0, 5], [260, 0, 6], [261, 0, 7],
                [262, 0, 8], [263, 0, 9], [264, 0, 10], [265, 1, 11], [266, 1, 13],
                [267, 1, 15], [268, 1, 17], [269, 2, 19], [270, 2, 23], [271, 2, 27],
                [272, 2, 31], [273, 3, 35], [274, 3, 43], [275, 3, 51], [276, 3, 59],
                [277, 4, 67], [278, 4, 83], [279, 4, 99], [280, 4, 115], [281, 5, 131],
                [282, 5, 163], [283, 5, 195], [284, 5, 227], [285, 0, 258]
            ];
            
            const entry = lengthTable[code - 257];
            if (entry[1] > 0) {
                const extraBits = reader.readBits(entry[1]);
                return entry[2] + extraBits;
            }
            return entry[2];
        }

        function readDistanceCode(reader) {
            // Fixed distance codes are 5 bits
            return reader.readBits(5);
        }

        function getDistanceFromCode(code, reader) {
            const distanceTable = [
                [0, 0, 1], [1, 0, 2], [2, 0, 3], [3, 0, 4], [4, 1, 5],
                [5, 1, 7], [6, 2, 9], [7, 2, 13], [8, 3, 17], [9, 3, 25],
                [10, 4, 33], [11, 4, 49], [12, 5, 65], [13, 5, 97], [14, 6, 129],
                [15, 6, 193], [16, 7, 257], [17, 7, 385], [18, 8, 513], [19, 8, 769],
                [20, 9, 1025], [21, 9, 1537], [22, 10, 2049], [23, 10, 3073],
                [24, 11, 4097], [25, 11, 6145], [26, 12, 8193], [27, 12, 12289],
                [28, 13, 16385], [29, 13, 24577]
            ];
            
            const entry = distanceTable[code];
            if (entry[1] > 0) {
                const extraBits = reader.readBits(entry[1]);
                return entry[2] + extraBits;
            }
            return entry[2];
        }

        function generateLZ77Text(length, distance, currentData) {
            // Generate the repeated text for LZ77 reference
            let result = '';
            const startPos = currentData.length - distance;
            
            for (let i = 0; i < length; i++) {
                const sourceIndex = startPos + (i % distance);
                if (sourceIndex >= 0 && sourceIndex < currentData.length) {
                    result += currentData[sourceIndex];
                }
            }
            
            return result;
        }

        function formatHexDump(data, highlightRanges = []) {
            const bytes = new Uint8Array(data);
            let result = '';
            
            for (let i = 0; i < bytes.length; i += 16) {
                // Hex bytes
                let hexLine = '';
                
                for (let j = 0; j < 16; j++) {
                    if (i + j < bytes.length) {
                        const byte = bytes[i + j];
                        const byteIndex = i + j;
                        const hexStr = byte.toString(16).padStart(2, '0').toUpperCase();
                        
                        // Check if this byte should be highlighted and get bit-level info
                        const highlightInfo = highlightRanges.find(range => 
                            byteIndex >= range.start && byteIndex < range.end
                        );
                        
                        if (highlightInfo) {
                            // Check if this is a partial byte highlight
                            if (byteIndex === highlightInfo.start && byteIndex === highlightInfo.end - 1) {
                                // Single byte with partial bit highlighting
                                const startBit = highlightInfo.startBitInByte || 0;
                                const endBit = highlightInfo.endBitInByte || 7;
                                const bitCount = endBit - startBit + 1;
                                const gradientPercent = (bitCount / 8) * 100;
                                const gradientOffset = (startBit / 8) * 100;
                                
                                const gradientStyle = `background: linear-gradient(90deg, 
                                    purple ${gradientOffset}%, 
                                    #2196f3 ${gradientOffset}%, 
                                    #2196f3 ${gradientOffset + gradientPercent}%, 
                                    purple ${gradientOffset + gradientPercent}%); 
                                    color: #fff; font-weight: bold;`;
                                
                                hexLine += `<span style="${gradientStyle}">${hexStr}</span>`;
                            } else if (byteIndex === highlightInfo.start) {
                                // Start byte with partial bit highlighting (right side)
                                const startBit = highlightInfo.startBitInByte || 0;
                                const gradientPercent = ((8 - startBit) / 8) * 100;
                                const gradientOffset = (startBit / 8) * 100;
                                
                                const gradientStyle = `background: linear-gradient(90deg, 
                                    purple ${gradientOffset}%, 
                                    #2196f3 ${gradientOffset}%, 
                                    #2196f3 100%); 
                                    color: #fff; font-weight: bold;`;
                                
                                hexLine += `<span style="${gradientStyle}">${hexStr}</span>`;
                            } else if (byteIndex === highlightInfo.end - 1) {
                                // End byte with partial bit highlighting (left side)
                                const endBit = highlightInfo.endBitInByte || 7;
                                const gradientPercent = ((endBit + 1) / 8) * 100;
                                
                                const gradientStyle = `background: linear-gradient(90deg, 
                                    #2196f3 0%, 
                                    #2196f3 ${gradientPercent}%, 
                                    purple ${gradientPercent}%); 
                                    color: #fff; font-weight: bold;`;
                                
                                hexLine += `<span style="${gradientStyle}">${hexStr}</span>`;
                            } else {
                                // Full byte highlight (middle bytes)
                                hexLine += `<span class="hex-highlight">${hexStr}</span>`;
                            }
                        } else if (i+j < 2 || i+j >= bytes.length - 4) {
                            hexLine += `<span class="hex-dim">${hexStr}</span>`;
                        } else {
                            hexLine += hexStr;
                        }
                        
                        // Add space after each byte (except the last one in the line)
                        if (j < 15 && i + j + 1 < bytes.length) {
                            hexLine += '<span style="display:inline-block; width: 2px;"></span>';
                        }
                    }
                }
                
                result += hexLine + '\n';
            }
            
            return result;
        }

        function updateItemDisplay(itemIndex) {
            if (deflateItems.length === 0) return;
            
            const item = deflateItems[itemIndex];
            const block = deflateBlocks[item.blockIndex];
            
            blockType.textContent = block.type;
            blockSize.textContent = block.size + ' bytes';
            blockPosition.textContent = `Item ${itemIndex + 1} of ${deflateItems.length} (Block ${item.blockIndex + 1})`;
            
            // Create item visualization
            let visualization = `Item ${itemIndex + 1} of ${deflateItems.length}\n`;
            visualization += `Block: ${item.blockIndex + 1} (${block.type})\n`;
            visualization += `Type: ${item.type.toUpperCase()}\n`;
            
            if (item.type === 'literal') {
                visualization += `Value: ${item.charCode} ('${item.value}')\n`;
            } else if (item.type === 'lz77') {
                visualization += `Length: ${item.length}\n`;
                visualization += `Distance: ${item.distance}\n`;
                visualization += `Text: "${item.text}"\n`;
            }
            
            blockVisualization.textContent = visualization;
            
            // Update highlighted text
            updateHighlightedTextForItem(item, itemIndex);
            
            // Update hex highlighting
            updateHexHighlighting(itemIndex);
        }

        function updateHexHighlighting(itemIndex) {
            if (deflateItems.length === 0) return;
            
            // Calculate byte ranges for the current item
            const item = deflateItems[itemIndex];
            const highlightRanges = calculateItemByteRanges(item, itemIndex);
            
            // Re-render hex dump with highlighting
            const compressed = fflate.zlibSync(new TextEncoder().encode(currentText), { level: 9, mem: 12 });
            const hexDump = formatHexDump(compressed, highlightRanges);
            hexOutput.innerHTML = hexDump;
        }

        function calculateItemByteRanges(item, itemIndex) {
            const ranges = [];
            
            // Convert bit positions to byte ranges, accounting for zlib header (2 bytes)
            const startByte = Math.floor(item.bitStart / 8) + 2;
            const endByte = Math.floor((item.bitEnd - 1) / 8) + 2;
            
            ranges.push({
                start: startByte,
                end: endByte + 1,
                type: item.type,
                bitStart: item.bitStart,
                bitEnd: item.bitEnd,
                startBitInByte: item.bitStart % 8,
                endBitInByte: (item.bitEnd - 1) % 8
            });
            
            return ranges;
        }

        function updateHighlightedTextForItem(item, itemIndex) {
            if (!currentText) return;
            
            // Build the decompressed text up to this point
            let decompressedSoFar = '';
            for (let i = 0; i <= itemIndex; i++) {
                const currentItem = deflateItems[i];
                if (currentItem.type === 'literal') {
                    decompressedSoFar += currentItem.value;
                } else if (currentItem.type === 'lz77') {
                    decompressedSoFar += currentItem.text;
                }
            }
            
            // Find this text in the original
            const textIndex = currentText.indexOf(decompressedSoFar);
            if (textIndex !== -1) {
                const before = currentText.substring(0, textIndex);
                const highlighted = currentText.substring(textIndex, textIndex + decompressedSoFar.length);
                const after = currentText.substring(textIndex + decompressedSoFar.length);
                
                // Highlight the current item specifically
                let highlightedText = before;
                
                // Add all previous items
                let currentPos = 0;
                for (let i = 0; i < itemIndex; i++) {
                    const prevItem = deflateItems[i];
                    if (prevItem.type === 'literal') {
                        highlightedText += prevItem.value;
                        currentPos += 1;
                    } else if (prevItem.type === 'lz77') {
                        highlightedText += prevItem.text;
                        currentPos += prevItem.text.length;
                    }
                }
                
                // Highlight the current item
                if (item.type === 'literal') {
                    highlightedText += `<span class="text-highlight">${item.value}</span>`;
                } else if (item.type === 'lz77') {
                    highlightedText += `<span class="text-highlight">${item.text}</span>`;
                }
                
                // Add remaining text
                const remainingStart = textIndex + decompressedSoFar.length;
                highlightedText += currentText.substring(remainingStart);
                
                textDisplay.innerHTML = highlightedText;
            } else {
                // Fallback: show the decompressed text
                textDisplay.innerHTML = `<span class="text-highlight">${decompressedSoFar}</span>`;
            }
        }

        function updateHighlightedText(block) {
            if (!currentText) return;
            
            // Show the decompressed data from this block
            let highlightedText = '';
            
            if (block.decompressedData) {
                // Try to map decompressed data to original text
                const decompressed = block.decompressedData;
                
                if (decompressed.includes('[LZ77:') || decompressed.includes('[Dynamic Huffman')) {
                    // For compressed blocks, show a representation
                    highlightedText = `<span class="text-highlight">${decompressed}</span>`;
                } else if (decompressed.length > 0) {
                    // For uncompressed blocks, try to find the text in the original
                    const textIndex = currentText.indexOf(decompressed);
                    if (textIndex !== -1) {
                        const before = currentText.substring(0, textIndex);
                        const after = currentText.substring(textIndex + decompressed.length);
                        highlightedText = before + `<span class="text-highlight">${decompressed}</span>` + after;
                    } else {
                        highlightedText = `<span class="text-highlight">${decompressed}</span>`;
                    }
                } else {
                    highlightedText = currentText;
                }
            } else {
                // Fallback to proportional highlighting
                const textLength = currentText.length;
                const blockCount = deflateBlocks.length;
                const charsPerBlock = Math.ceil(textLength / blockCount);
                
                const start = block.index * charsPerBlock;
                const end = Math.min(start + charsPerBlock, textLength);
                
                if (start > 0) {
                    highlightedText += currentText.substring(0, start);
                }
                highlightedText += `<span class="text-highlight">${currentText.substring(start, end)}</span>`;
                if (end < textLength) {
                    highlightedText += currentText.substring(end);
                }
            }
            
            textDisplay.innerHTML = highlightedText;
        }

        function setupItemNavigation() {
            console.log('Setting up item navigation. Items found:', deflateItems.length);
            console.log('Items:', deflateItems);
            
            if (deflateItems.length === 0) {
                deflateBreakdown.style.display = 'none';
                highlightedText.style.display = 'none';
                return;
            }
            
            deflateBreakdown.style.display = 'block';
            highlightedText.style.display = 'block';
            
            blockSlider.max = Math.max(0, deflateItems.length - 1);
            blockSlider.value = 0;
            blockInfo.textContent = `Item 1 of ${deflateItems.length}`;
            
            updateItemDisplay(0);
        }

        function compressAndDisplay() {
            const text = inputText.value;
            currentText = text;
            
            if (!text.trim()) {
                hexOutput.innerHTML = '<div class="no-data">Enter some text to see the compressed zlib stream as hex...</div>';
                stats.style.display = 'none';
                deflateBreakdown.style.display = 'none';
                highlightedText.style.display = 'none';
                return;
            }

            try {
                // Convert text to bytes
                const textBytes = new TextEncoder().encode(text);
                
                // Compress using fflate zlib with level 9
                const compressed = fflate.zlibSync(textBytes, { level: 9, mem: 12 });
                
                // Display hex dump
                const hexDump = formatHexDump(compressed);
                hexOutput.innerHTML = hexDump;
                
                // Parse DEFLATE blocks
                deflateBlocks = parseDeflateBlocks(compressed);
                
                // Collect all items from all blocks
                deflateItems = [];
                deflateBlocks.forEach(block => {
                    if (block.items) {
                        block.items.forEach((item, index) => {
                            deflateItems.push({
                                ...item,
                                blockIndex: block.index,
                                itemIndex: index,
                                globalIndex: deflateItems.length
                            });
                        });
                    }
                });
                
                console.log('Total items:', deflateItems.length);
                console.log('Items:', deflateItems);
                
                // Update statistics
                const originalSizeBytes = textBytes.length;
                const compressedSizeBytes = compressed.length;
                const ratio = ((1 - compressedSizeBytes / originalSizeBytes) * 100).toFixed(1);
                
                originalSize.textContent = originalSizeBytes + ' bytes';
                compressedSize.textContent = compressedSizeBytes + ' bytes';
                compressionRatio.textContent = ratio + '%';
                
                // Add red color class if compression ratio is negative
                if (parseFloat(ratio) < 0) {
                    compressionRatio.classList.add('negative');
                } else {
                    compressionRatio.classList.remove('negative');
                }
                
                stats.style.display = 'block';
                setupItemNavigation();
                
            } catch (error) {
                hexOutput.innerHTML = '<div class="no-data" style="color: #dc3545;">Error compressing text: ' + error.message + '</div>';
                stats.style.display = 'none';
                deflateBreakdown.style.display = 'none';
                highlightedText.style.display = 'none';
            }
        }

        // Add event listener for real-time compression
        inputText.addEventListener('input', compressAndDisplay);
        
        // Add event listener for item slider
        blockSlider.addEventListener('input', function() {
            const itemIndex = parseInt(this.value);
            blockInfo.textContent = `Item ${itemIndex + 1} of ${deflateItems.length}`;
            updateItemDisplay(itemIndex);
        });
        
        // Initial call to handle any pre-filled content
        compressAndDisplay();
    </script>
</body>
</html>
